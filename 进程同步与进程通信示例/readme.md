## 设计思路

创建一个信号量集, 包括三个信号量:

1. mutex作为控制信号量, 初始值为1. 用来保护缓冲区本身;
2. empty代表空的缓冲数目, 初始值为N. 表示缓冲区中空闲的区块数量, 可以由N个生产获取到, 然后将任务放进去;
3. full代表缓冲区中已经被占用的数量, 也是消费者可以消费的任务数量, 初始值为0;

创建缓冲区, 用共享内存方式实现.

缓冲区用一个有10个元素的整数数组表示. in, out分别表示下一个将被生产和被消费的缓冲元素的下标;

生产者每生产一个产品, in便向后移动一个位置, 且生产者只能对full信号量进行加1操作, 对empty信号量只能进行减1操作;

而消费者每消费一个产品, out便向后移动一个位置, 且消费者只能对empty信号量进行加1操作, 对full信号量只能进行减1操作;

当in == out时, 缓冲区为空. 

C中没有队列, 我们通过用缓冲区+游标的方式表示任务, 所以生产者和消费者要加锁的目标是不同的. 

普通的队列只要向队列本身加锁就可以了, 而在我们的模型中, 生产者间竞争的是游标in, 消费者间竞争的是游标out. 同时生产者消费者之间会同时竞争缓冲区数组, 因为需要修改其中的值.

生产者间先竞争empty信号量, 以确定缓冲区中仍然有空闲区块, 然后竞争mutex信号量, 以改写缓冲区中的内容. 改写操作包括将in的游标向后移动1位, 并将对应的区块内容置为1, 表示已有任务占用. 之后依次释放mutex和empty.

消费者间先竞争full信号量, 以确定缓冲区中有已经被占用的区块, 即任务, 然后竞争mutex信号量, 同样是改写缓冲区内容, 只不过与生产者操作相反. 完成后也要依次释放mutex和full.

其实这一"生产-消费"过程并不需要共享内存来实现, 因为信号量本身就可以表示任务的总量和可用数量. 这里只不过是为了初中进程通信强加的示例.

生成的程序在运行时使用ctrl-c取消后可能会造成死锁, 需要捕获ctrl-c, 手动释放信号量才行.

## 运行

```
docker run -it --name sema -v d:/coding/sema:/root/sema generals/centos7 /bin/bash
```

当前目录下执行make可以得到init, clear, producer, consumer 4个可执行文件.

执行init后, 使用ipcs命令查看, 可得到如下输出

```
------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status
0x000004d2 0          root       666        48         0

------ Semaphore Arrays --------
key        semid      owner      perms      nsems
0x000004d2 0          root       666        3

```

之后可以运行多个producer和consumer.

如果不手动调用clear的话, 信号量, 共享内存对象会一直存在, 直到重启. ipcs只能看, 不能有其他操作...
