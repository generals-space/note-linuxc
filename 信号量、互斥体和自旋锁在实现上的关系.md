# 信号量、互斥体和自旋锁在实现上的关系

1. [【APUE】信号量、互斥体和自旋锁](https://www.cnblogs.com/ljygoodgoodstudydaydayup/p/3885357.html)
    - 信号量semaphore, 互斥体mutex, 自旋锁spin lock的概念和关系
    - 对自旋锁的适用情况解释得比较清晰
    - 进程上下文和内核抢占的概念和意义


信号量和互斥体之间的区别

概念上的区别

- 信号量: 是进程间(线程间)同步用的, 一个进程(线程)完成了某一个动作就通过信号量告诉别的进程(线程), 别的进程(线程)再进行某些动作. 
有二值和多值信号量之分. 
- 互斥锁: 是线程间互斥用的, 一个线程占用了某一个共享资源, 那么别的线程就无法访问, 直到这个线程离开, 其他的线程才开始可以使用这个共享资源. 可以把互斥锁看成二值信号量. 

> "二值"是指0和1吧?

上锁时: 

- 信号量: 只要信号量的value大于0, 其他线程就可以sem_wait成功, 成功后信号量的value减一. 若value值不大于0, 则sem_wait阻塞, 直到sem_post释放后value值加一. 一句话, 信号量的value>=0. 
- 互斥锁: 只要被锁住, 其他任何线程都不可以访问被保护的资源. 如果没有锁, 获得资源成功, 否则进行阻塞等待资源可用. 一句话, 线程互斥锁的vlaue可以为负数. 

使用场所: 

信号量主要适用于进程间通信, 当然, 也可用于线程间通信. 而互斥锁只能用于线程间通信. 

Linux2.6.26下定义的信号量结构体(这是内核的实现代码, 位置在`src/linux/include/linux/sem.h`)

```c++
struct semaphore {
    spinlock_t                lock;
    unsigned int             count;
    struct list_head        wait_list;
};
```

1. semaphore底层使用到了spinlock的锁定机制, 这个spinlock主要用来确保对count成员的原子性的操作(count--)和测试(count > 0)
2. 从原理上讲, mutex实际上是count=1情况下的semaphore, 底层实现和semaphore几乎一样. 

## 扩展

### 进程上下文与中断上下文

进程上下文: 

在Linux中, 用户程序装入系统形成一个进程的实质是系统为用户程序提供一个完整的运行环境. 进程的运行环境是由它的程序代码和程序运行所需要的数据结构以及硬件环境组成的. 进程的运行环境主要包括: 

1.进程空间中的代码和数据、各种数据结构、进程堆栈和共享内存区等. 
2.环境变量: 提供进程运行所需的环境信息. 
3.系统数据: 进程空间中的对进程进行管理和控制所需的信息, 包括进程任务结构体以及内核堆栈等. 
4.进程访问设备或者文件时的权限. 
5.各种硬件寄存器. 
6.地址转换信息. 

从以上组成情况可以看到, 进程的运行环境是动态变化的, 尤其是硬件寄存器的值以及进程控制信息是随着进程的运行而不断变化的. 在Linux中把系统提供给进程的的处于动态变化的运行环境总和称为进程上下文. 

系统中的每一个进程都有自己的上下文. 一个正在使用处理器运行的进程称为当前进程(current). 当前进程因时间片用完或者因等待某个事件而阻塞时, 进程调度需要把处理器的使用权从当前进程交给另一个进程, 这个过程叫做进程切换. 此时, 被调用进程成为当前进程. 在进程切换时系统要把当前进程的上下文保存在指定的内存区域(该进程的任务状态段TSS中), 然后把下一个使用处理器运行的进程的上下文设置成当前进程的上下文. 当一个进程经过调度再次使用CPU运行时, 系统要恢复该进程保存的上下文. 所以, 进程的切换也就是上下文切换. 

在系统内核为用户进程服务时, 通常是进程通过系统调用执行内核代码, 这时进程的执行状态由用户态转换为内核态. 但是, 此时内核的运行是为用户进程服务, 也可以说内核在代替当前进程执行某种服务功能. 在这种情况下, 内核的运行仍是进程运行的一部分, 所以说这时内核是运行在进程上下文中. 内核运行在进程上下文中时可以访问和修改进程的系统数据. 此外, 若内核运行在进程上下文中需要等待资源和设备时, 系统可以阻塞当前进程.

中断上下文: 

硬件通过触发信号, 导致内核调用中断处理程序, 进入内核空间. 这个过程中, 硬件的一些变量和参数也要传递给内核, 内核通过这些参数进行中断处理. 所谓的"中断上下文", 其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境(主要是当前被打断执行的进程环境). 中断时, 内核不代表任何进程运行, 它一般只访问系统空间, 而不会访问进程空间, 内核在中断上下文中执行时一般不会阻塞.

### 抢占式内核与非抢占式内核

可抢占式内核: 即当进程位于内核空间时, 有一个更高优先级的任务出现时, 如果当前内核允许抢占, 则可以将当前任务挂起, 执行优先级更高的进程. 

非抢占式内核: 高优先级的进程不能中止正在内核中运行的低优先级的进程而抢占CPU运行. 进程一旦处于核心态(例如用户进程执行系统调用), 则除非进程自愿放弃CPU, 否则该进程将一直运行下去, 直至完成或退出内核.

抢占式内核的意义: 首先, 这是将Linux应用于实时系统所必需的. 实时系统对响应时间有严格的限定, 当一个实时进程被实时设备的硬件中断唤醒后, 它应在限定的时间内被调度执行. 而Linux不能满足这一要求, 因为Linux的内核是不可抢占的, 不能确定系统在内核中的停留时间. 事实上当内核执行长的系统调用时, 实时进程要等到内核中运行的进程退出内核才能被调度, 由此产生的响应延迟, 在如今的硬件条件下, 会长达100ms级. 这对于那些要求高实时响应的系统是不能接受的. 而可抢占的内核不仅对Linux的实时应用至关重要, 而且能解决Linux对多媒体(video, audio)等要求低延迟的应用支持不够好的缺陷. 
